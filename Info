realloc vom Workspace schlÃ¤gt scheinbar fehl.
Es wird hinter die maximale GrÃ¶ÃŸe geschrieben


hm, wenn ich max_comp vergrÃ¶ÃŸere und damit eine reallokierung verhindere, tritt
das Problem nicht auf. Irgendwie wird der Zustand id>max_comp erreicht, obwohl
das da abgefangen wird.



Aha, comp_same (cs) ist keine Projektion, erst csÂ = csÂ³


Hm, im workspace mÃssen die Relationen der ids und ihre Elternrelationen enthalten
sein, da die Clientprogramme diese Daten zum filtern brauchen kÃnnten.
final_ids sollten aber nicht wie derzeit behandelt werden, da so Ãber dem ganzen Bild gearbeitet
wird?! Naja, es ist nur eine verschiebung der Operation f(pixel) von Client zu Server oder umgekehrt.... 


Man muss die Filter auf die Knoten anwerden kÃnnen so dass 
die Id eines Pixels zum Elternknoten geÃndert wird, falls die Id herausgefiltern wird?

Dazu muss man nicht alle Pixel Ãndern, sondern nur comp_same!

=>
blob_id_filtered
gen_blob_id


Fuck, der Fehler ist noch da:
*** glibc detected *** ./DisplayImage: realloc(): invalid next size: 0x09870320 ***


Fuck, real_ids haben nichts mit den internen Ids zu tun!
Comp_same arbeitet auf den Ids 
-> ich mÃsste zu dem Zeitpunkt eine Karte fÃr realids erstellen,
die realids auf die ids in den datenstruckturen abbildet.
Nur dann kann ich diese interen datenstrukturen weiterverwenden.



Idee für frameübergreifende Erkennung von Bewegungen:
Versuche nichtleere Schnitte von Flächen oder deren Bounding-Boxes zu finden?!
Dort,  wo man in 3 von 5 Frames etwas findet muss was los sein?!
Simple Schnitte berücksichtigen aber nicht den Bewegungsvektor, der ja 
die gesuchte Fläche verschiebt.

Neue Idee: Vergleiche Stelle mit Bewegungen mit dem potentiellen
Umriss einer Hand?! (nicht frameübergreifend, Hand=Stumpfes Ende einer größeren Fläche).


Problem für die zweite Zeile:
Es kann teilweise auf nichtgesetzte Stellen zugegriffen werden.
Da fehlt die Info, ob diese Stellen überhaupt gesetzt sind....

Die Tri-Information sagt etwas über die Fläche eines Qudrates aus
(tri-1) == 2: Fläche komplett gefüllt.
(tri-1) == 1: Dreieck gefüllt.

(tri-triwidth) == 2: Untere Reihe der vorigen Quadradreihe ist gefüllt.
(In Bezug auf zweite Zeile, sonst ist es mehr Info.)



Ah: Erste Zeile -> Tri auf 2 setzen
Beim Problem: Falls tri==0, Ganzes Quad darüber berechnen?!
Falls tri==1 Dreieck darüber berechnen.

Nein, es war so: Wenn das Quadrat darüber nicht berechnet wurde wird 
nur die untere Zwischenzeile berechnet.
